// EJEMPLO DE USO - main.go refactorizado con arquitectura hexagonal y shared
//
// Este archivo muestra cómo integrar el módulo shared y la nueva arquitectura
// en el main.go de API Administración
//
// NO EJECUTAR ESTE ARCHIVO - Es solo un ejemplo de referencia
// Para usarlo, copiar el contenido a cmd/main.go

package main

import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"

	"github.com/edugo/api-administracion/internal/container"
	"github.com/edugo/shared/pkg/config"
	"github.com/edugo/shared/pkg/database/postgres"
	"github.com/edugo/shared/pkg/logger"
)

func main() {
	// 1. Crear logger usando shared (JSON para producción, console para desarrollo)
	logFormat := "json"
	logLevel := "info"
	if config.IsDevelopment() {
		logFormat = "console"
		logLevel = "debug"
	}

	log := logger.NewZapLogger(logLevel, logFormat)
	defer log.Sync()

	log.Info("Starting API Administración",
		"version", "1.0.0",
		"environment", config.GetEnvironment(),
	)

	// 2. Conectar a PostgreSQL usando shared
	dbConfig := postgres.Config{
		Host:           config.GetEnv("DB_HOST", "localhost"),
		Port:           config.GetEnvInt("DB_PORT", 5432),
		Database:       config.GetEnv("DB_NAME", "edugo"),
		User:           config.GetEnv("DB_USER", "edugo_user"),
		Password:       config.GetEnvRequired("DB_PASSWORD"), // Requerido
		MaxConnections: config.GetEnvInt("DB_MAX_CONNECTIONS", 25),
		SSLMode:        config.GetEnv("DB_SSL_MODE", "disable"),
	}

	db, err := postgres.Connect(dbConfig)
	if err != nil {
		log.Fatal("Failed to connect to database", "error", err)
	}
	defer postgres.Close(db)

	log.Info("Connected to PostgreSQL",
		"host", dbConfig.Host,
		"database", dbConfig.Database,
	)

	// Verificar health de la DB
	if err := postgres.HealthCheck(db); err != nil {
		log.Fatal("Database health check failed", "error", err)
	}

	// 3. Inicializar DI Container con todas las dependencias
	container := container.NewContainer(db, log)
	defer container.Close()

	log.Info("Dependency injection container initialized")

	// 4. Configurar Gin router
	if config.IsProduction() {
		gin.SetMode(gin.ReleaseMode)
	}

	router := gin.New()

	// Middlewares globales
	router.Use(gin.Recovery())
	router.Use(loggingMiddleware(log))

	// Health check endpoint (sin autenticación)
	router.GET("/health", func(c *gin.Context) {
		// Verificar DB
		if err := postgres.HealthCheck(db); err != nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{
				"status": "unhealthy",
				"error":  "database unavailable",
			})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"status": "healthy",
			"service": "api-administracion",
		})
	})

	// 5. Rutas con nuevo handler refactorizado
	v1 := router.Group("/v1")
	{
		// Guardian relations endpoints
		guardians := v1.Group("/guardian-relations")
		{
			guardians.POST("", container.GuardianHandler.CreateGuardianRelation)
			guardians.GET("/:id", container.GuardianHandler.GetGuardianRelation)
		}

		// Guardian-specific routes
		v1.GET("/guardians/:guardian_id/relations", container.GuardianHandler.GetGuardianRelations)

		// Student-specific routes
		v1.GET("/students/:student_id/guardians", container.GuardianHandler.GetStudentGuardians)

		// Aquí se agregarían más handlers cuando se refactoricen
		// users.POST("/users", container.UserHandler.CreateUser)
		// schools.POST("/schools", container.SchoolHandler.CreateSchool)
		// etc.
	}

	// 6. Configurar servidor HTTP
	port := config.GetEnv("PORT", "8081")
	srv := &http.Server{
		Addr:         ":" + port,
		Handler:      router,
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 30 * time.Second,
	}

	// 7. Iniciar servidor en goroutine
	go func() {
		log.Info("Server starting", "port", port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatal("Server failed to start", "error", err)
		}
	}()

	// 8. Graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Info("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		log.Fatal("Server forced to shutdown", "error", err)
	}

	log.Info("Server exited gracefully")
}

// loggingMiddleware crea un middleware de logging usando shared/logger
func loggingMiddleware(log logger.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path
		method := c.Request.Method

		// Procesar request
		c.Next()

		// Log después de procesar
		duration := time.Since(start)
		statusCode := c.Writer.Status()

		log.Info("HTTP request",
			"method", method,
			"path", path,
			"status", statusCode,
			"duration_ms", duration.Milliseconds(),
			"ip", c.ClientIP(),
		)
	}
}

/* VARIABLES DE ENTORNO REQUERIDAS:

# Base de datos (requerido)
export DB_PASSWORD="edugo_pass"

# Base de datos (opcionales con defaults)
export DB_HOST="localhost"
export DB_PORT="5432"
export DB_NAME="edugo"
export DB_USER="edugo_user"
export DB_MAX_CONNECTIONS="25"
export DB_SSL_MODE="disable"

# Servidor (opcionales)
export PORT="8081"
export APP_ENV="development"  # development, staging, production

# Logger
export LOG_LEVEL="info"  # debug, info, warn, error

*/

/* EJEMPLO DE TABLA SQL PARA GUARDIAN_RELATIONS:

CREATE TABLE IF NOT EXISTS guardian_relations (
    id UUID PRIMARY KEY,
    guardian_id UUID NOT NULL,
    student_id UUID NOT NULL,
    relationship_type VARCHAR(50) NOT NULL CHECK (relationship_type IN ('parent', 'guardian', 'relative', 'other')),
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    created_by VARCHAR(255) NOT NULL,

    CONSTRAINT unique_active_relation UNIQUE (guardian_id, student_id, is_active) WHERE is_active = true
);

CREATE INDEX idx_guardian_relations_guardian_id ON guardian_relations(guardian_id);
CREATE INDEX idx_guardian_relations_student_id ON guardian_relations(student_id);
CREATE INDEX idx_guardian_relations_is_active ON guardian_relations(is_active);

*/
